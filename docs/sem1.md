# Вопросы к экзамену за I ceместр

<details>
  <summary> <b> 1. Переменные и типы данных в C++. Область видимости переменной. </b> </summary>
  <br>
  
Синтаксис объявления, присваивания, использования переменных. Базовые (примитивные) типы данных: целочисленный, вещественный, символьный, логический. Как устроены числа со знаком, как устроены числа "с плавующей точкой" (отличия `float`, `double`, `long double`). Оператор `typedef`, что есть на самом деле `intX_t`/`uintX_t`? Уметь работать с `bin`/`hex` сис-мами исчисления, понимать принципы вычисления кол-ва значений и min/max диапазонов целочисленных типов данных. `const`/`constexpr`, для чего используется, разница. Область видимости переменной (глобальная, локальная (внутри ф-ции или `{}`))
</details>

<!-- ================================================================ -->

<details>
  <summary> <b> 2. Условные ветвления и циклы. Операторы. </b> </summary>
  <br>
  
`if`, `else`, `else if`, `switch` (и с какими типами данных он работает). `while`, `do-while`, `for` (на какие сегменты делится, порядок их исполнения). `break`, `continue`, `goto`. Варианты синтаксиса скобок в условных ветвлениях и циклах. Оператор как функция (принимает, возвращает, аргументы = опреранды). Унарные (префиксные / постфиксные), бинарные, тернарный, примеры. Разница между префикс / постфикс инк(дек)рементом. Оператор присваивания (`=`). Составные операторы присваивания (`+=`, `-=`, ...).
</details>

<!-- ================================================================ -->

<details>
    <summary> <b> 3. Составные типы данных - указатель и ссылка. Операторы new / delete. </b> </summary>
    <br>

Синтаксис объявления указателей. Что хранит, на что указывает. Значение и варианты использования const при объявлении указателей (чтение справа-налево). Операторы разыменования (`*`) и взятия адреса (`&`). Арифметика указателей, оператор `[]`. Описание работы `new` / `delete`, пример с выделением и очисткой динамической памяти под матрицу в смысле указателя на массив указателей. Проблемы с указателями (garbage value (wild pointer), memory leak, ownership problem).
Синтаксис объявления ссылок. Что хранит (хранит ли?), на что ссылается. Отличия ссылок и указателей (указатель м.б. `nullptr`, можно переприсвоить, занимает память, реализована арифметика).
</details>

<!-- ================================================================ -->

<details>
    <summary> <b> 4. Функции, перегрузки, значения параметров по умолчанию. Рекурсия. </b> </summary>
    <br>
  
Синтаксис объявления, передачи параметров и вызова функций. Понятия сигнатуры и тела функции. Синтаксис объявления указателя на функцию. Примеры перегрузки функции с разными параметрами. Установка значений параметров по умолчанию и требование их нахождения в конце списка параметров. Разница передачи в функцию значения и ссылки. Пример рекурсивной функции, пролема переполнения стека.
</details>

<!-- ================================================================ -->

<details>
    <summary> <b> 5. Побитовые операторы, сдвиги, основные приёмы. </b> </summary>
    <br>

</details>

<!-- ================================================================ -->

<details>
    <summary> <b> 6. Процесс трансляции C++ кода в исполняемый файл. Области памяти исполняемой программы на C++. </b> </summary>
    <br>

Классический вариант: `Препроцессор` -> `компилятор` -> `ассемблер` -> `линкер` -> `исполняемый файл`. Рассказать про каждый этап. Стек, куча, сегмент данных, сегмент BSS, текстовый сегмент. Рассказать про назначение, базовые принципы работы стека. Привести пример объявления переменных во всех 4-ёх сегментах, кроме текстового (стек - локальная, куча - через `new`, data - глобальная инициализированная, bss - глобальная неинициализированная).
</details>

<!-- ================================================================ -->

<details>
    <summary> <b> 7. Алгоритмы. Пос-ть Фиббоначи. Линейный и бинарный поиск. Reverse, shift массива. Соответсвующие оценки сложности. Swap целых чисел через + и xor. Вычисление бита чётности (parity bit) за n и log(n). </b> </summary>
<br>

Понятие сложности алгоритма. Вычисление n-го элемента пос-ти Фиббоначи, рекурсивная и циклическая реализации, императивный и декларативный стили. Поиск заданного эл-та в массиве, линейный (с разных сторон), бинарный. Reverse массива "на месте", shift через 3 reverse'а. Parity bit через xor на сдвиги на n/2.
</details>

<!-- ================================================================ -->

<details>
    <summary> <b> 8. Алгоритмы. Сортировки n^2: выбором, вставкой, пузырьком (оптимизации: перемешиванием, расчёской). Сортировки n^log(n): слиянием, быстрая, пирамидальная. Сортировки n: подсчётом. </b> </summary>
    <br>

Понятия сортировок "на месте", устойчивости сортировки, класс сортировок сравнением (comparison & non-comparison sorts).
</details>
